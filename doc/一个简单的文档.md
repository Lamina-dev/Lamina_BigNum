# 1. 开发者文档

开发者文档主要包含项目的开发环境、编译方法、测试方法、项目组成、代码风格等。

## 1.1 开发环境
暂无描述

## 1.2 编译方法
使用camke编译，编译命令如下：
```cmake
# CMakeList.txt: LargeDynamicBitSetAndIntegerNumber 的 CMake 项目，在此处包括源代码并定义
# 项目特定的逻辑。
#
cmake_minimum_required (VERSION 3.10)

#set(CMAKE_BUILD_TYPE release)

project ("LargeDynamicBitSetAndIntegerNumber")

# 设置默认的构建类型为 Debug，如果没有指定构建类型
if(NOT CMAKE_BUILD_TYPE)
	set(CMAKE_CXX_STANDARD 17)
	set(CMAKE_CXX_STANDARD_REQUIRED ON)
	set(CMAKE_CXX_EXTENSIONS OFF)
	set(CMAKE_BUILD_TYPE debug CACHE STRING "Choose the type of build (Debug or Release)" FORCE)
endif()

# 设置 Debug 和 Release 的编译选项

if(MSVC)
	add_compile_options(/W4 /Zc:__cplusplus /utf-8)
else()
	if(CMAKE_CXX_COMPILER_ID STREQUAL "GNU")
		if(CMAKE_CXX_COMPILER_VERSION VERSION_LESS "11")
			message(FATAL_ERROR "GNU CXX compiler version is too small !")
		endif()
		if(CMAKE_BUILD_TYPE EQUAL release)
			add_compile_options(-Wall -O2 -Wextra -fsigned-char -finput-charset=UTF-8 -fexec-charset=UTF-8)
		else()
			add_compile_options(-g -O0 -Wall -Wextra -fsigned-char -finput-charset=UTF-8 -fexec-charset=UTF-8)
		endif()
	endif()
endif()

add_library(BigNumberSystem
	src/BigInt.hpp
	src/BigInt.cpp
	src/BigFrac.hpp
	src/BigFrac.cpp
 )

add_executable(Test
	Test.cpp
	main.cpp
)

if (CMAKE_VERSION VERSION_GREATER 3.12)
	set_property(TARGET BigNumberSystem PROPERTY CXX_STANDARD 17)
    set_property(TARGET Test PROPERTY CXX_STANDARD 17)
    set_property(TARGET BigNumberSystem PROPERTY CXX_STANDARD_REQUIRED ON)
    set_property(TARGET Test PROPERTY CXX_STANDARD_REQUIRED ON)
endif()

# TODO: 如有需要，请添加测试并安装目标。
```

## 1.3 测试方法

暂无描述

## 1.4 项目组成

项目主要包含三个部分：
1. 任意精度计算库：主要为``hint.hpp``单文件，主命名空间为``HyperInt``
2. 大整数类：主要为``BigInt.hpp``和``BigInt.cpp``两个文件，主命名空间为``__LAMINA::BIGINT``
3. 分数类：主要为``BigFrac.hpp``和``BigFrac.cpp``两个文件，主命名空间为``__LAMINA::BIGFRAC``

下面依次介绍每个部分的功能和使用。

## 1.4.1 任意精度计算库

任意精度计算库为``hint.hpp``单文件，命名空间为``HyperInt``，主要包含以下模板函数和子命名空间：

1. 一些模板函数
2. ``Transform``命名空间，该命名空间包含：
   1. 模板函数``transform2``
   1. ``NumberTheoreticTransform``命名空间，该命名空间包含：
      1. ``InternalUInt128``类，用于内部的 128 位无符号整数运算。
      2. ``InternalUInt192``类，用于内部的 192 位无符号整数运算。
      3. ``MontInt64Lazy``类，用于 64 位整数的蒙特卡罗乘法。
      4. ``SplitRadix``命名空间，蝴蝶变换及其模板算法。
3. ``Arithmetic``命名空间，该命名空间包含：
   1. 各类高精度数组整数运算模板函数和非模板函数。
   2. ``Numeral``命名空间，该命名空间包含：
      1. ``BaseTable``命名空间，主要作为进制常数表。
      2. 转换函数等。

## 1.4.2 大整数类

大整数类为``BigInt.hpp``和``BigInt.cpp``两个文件，命名空间为``__LAMINA::BIGINT``，主要包含一个类``BigInteger``。

## 1.4.3 分数类

分数类为``BigFrac.hpp``和``BigFrac.cpp``两个文件，命名空间为``__LAMINA::BIGFRAC``，主要包含一个类``BigFraction``。


# 2. 使用文档

使用文档主要包含公用接口函数以及类的详细使用说明，内部接口函数及使用请见于开发者文档（~~好趴，你还看不到就是了~~）。下面主要以功能和使用来介绍。

## 2.1 128 位相关计算

库中包含多个 128 位计算函数和一个 128 位无符号数类的实现。

### 2.1.1 64x64 位计算

- **函数名称：**`mul64x64to128_base`
- 定义方式：
  `constexpr void mul64x64to128_base(uint64_t a, uint64_t b, uint64_t& low, uint64_t& high)`

- 所在命名空间：`HyperInt`

- 输入和输出如下：

  - 输入参数：
    1. `uint64_t a`：第一个 64 位无符号整数乘数。
    2. `uint64_t b`：第二个 64 位无符号整数乘数。
  - 输出参数（通过引用返回）：
    1. `uint64_t& low`：存放乘积的低 64 位。
    2. `uint64_t& high`：存放乘积的高 64 位。

  该函数将两个 64 位无符号整数相乘，结果以 128 位无符号整数的形式输出，低 64 位赋值给 low，高 64 位赋值给 high。

- 推荐调用格式：

  ```cpp
  uint64_t high, low;
  HyperInt::mul64x64to128_base( 217878123891823910ull, 12738712989743ull, low, high );
  ```

- **函数名称：**`mul64x64to128`

- 定义方式：

  ```cpp
  inline void mul64x64to128(uint64_t a, uint64_t b, uint64_t& low, uint64_t& high)
  ```

- 所在命名空间：`HyperInt`

- 输入和输出如下：

  - 输入参数：
    1. `uint64_t a`：第一个 64 位无符号整数乘数。
    2. `uint64_t b`：第二个 64 位无符号整数乘数。
  - 输出参数（通过引用返回）：
    1. `uint64_t& low`：存放乘积的低 64 位。
    2. `uint64_t& high`：存放乘积的高 64 位。

  该函数将两个 64 位无符号整数相乘，结果以 128 位无符号整数的形式输出，低 64 位赋值给 low，高 64 位赋值给 high。该函数会根据平台自动选择的实现方式（ `_umul128`、`__uint128_t` 和`mul64x64to128_base` ）。

- 推荐调用格式：

  ```cpp
  uint64_t high, low;
  HyperInt::mul64x64to128(217878123891823910ull, 12738712989743ull, low, high);
  ```

---

### 2.1.2 128 位除 32 位计算

- **函数名称：**`div128by32`

- 定义方式：

  ```cpp
  constexpr uint32_t div128by32(uint64_t& dividend_hi64, uint64_t& dividend_lo64, uint32_t divisor)
  ```

- 所在命名空间：`HyperInt`

- 输入和输出如下：

  - 输入参数：
    1. `uint64_t& dividend_hi64`：128 位被除数的高 64 位（输入时为高位，输出时被修改为部分商）。
    2. `uint64_t& dividend_lo64`：128 位被除数的低 64 位（输入时为低位，输出时被修改为部分商）。
    3. `uint32_t divisor`：32 位无符号整数除数。
  - 输出参数（返回值）：
    1. `uint32_t`：返回 128 位被除数除以 32 位除数后的余数。

  该函数将一个 128 位无符号整数（由 high 和 low 两个 64 位部分组成）除以一个 32 位无符号整数，结果将商分别写回 high 和 low，返回余数。

- 推荐调用格式：

  ```cpp
  uint64_t hi = 0x1234567890ABCDEF, lo = 0xFEDCBA0987654321;
  uint32_t divisor = 123456789;
  uint32_t remainder = HyperInt::div128by32(hi, lo, divisor);
  ```

---

### 2.1.3 96 位除 64 位计算

- **函数名称：**`div96by64to32`

- 定义方式：

  ```cpp
  constexpr uint32_t div96by64to32(uint32_t dividend_hi32, uint64_t& dividend_lo64, uint64_t divisor)
  ```

- 所在命名空间：`HyperInt`

- 输入和输出如下：

  - 输入参数：
    1. `uint32_t dividend_hi32`：96 位被除数的高 32 位。
    2. `uint64_t& dividend_lo64`：96 位被除数的低 64 位（输入时为低位，输出时被修改为余数）。
    3. `uint64_t divisor`：64 位无符号整数除数。
  - 输出参数（返回值）：
    1. `uint32_t`：返回 96 位被除数除以 64 位除数后的商，`dividend_lo64` 被修改为余数。

  该函数将一个 96 位无符号整数（高 32 位和低 64 位组成）除以一个 64 位无符号整数，返回商，并将余数写回 `dividend_lo64`。

- 推荐调用格式：

  ```cpp
  uint32_t hi32 = 0x12345678;
  uint64_t lo64 = 0x90ABCDEF12345678;
  uint64_t divisor = 0x1FEDCBA987654321;
  uint32_t quotient = HyperInt::div96by64to32(hi32, lo64, divisor);
  // lo64 现在为余数
  ```

---

### 2.1.4 128 位除 64 位计算

- **函数名称：**`div128by64to64`

- 定义方式：

  ```cpp
  constexpr uint64_t div128by64to64(uint64_t dividend_hi64, uint64_t& dividend_lo64, uint64_t divisor)
  ```

- 所在命名空间：`HyperInt`

- 输入和输出如下：

  - 输入参数：
    1. `uint64_t dividend_hi64`：128 位被除数的高 64 位。
    2. `uint64_t& dividend_lo64`：128 位被除数的低 64 位（输入时为低位，输出时被修改为余数）。
    3. `uint64_t divisor`：64 位无符号整数除数。
  - 输出参数（返回值）：
    1. `uint64_t`：返回 128 位被除数除以 64 位除数后的商，`dividend_lo64` 被修改为余数。

  该函数将一个 128 位无符号整数（由高 64 位和低 64 位组成）除以一个 64 位无符号整数，返回商，并将余数写回 `dividend_lo64`。

- 推荐调用格式：

  ```cpp
  uint64_t hi = 0x1234567890ABCDEF, lo = 0xFEDCBA0987654321;
  uint64_t divisor = 0x1FEDCBA987654321;
  uint64_t quotient = HyperInt::div128by64to64(hi, lo, divisor);
  // lo 现在为余数
  ```

---

## 2.2 高精度相关计算

### 2.2.1 高精度移位计算

- **函数名称：**`lshift_in_word`

- 定义方式：

  ```cpp
  template <typename WordTy>
  constexpr void lshift_in_word(const WordTy in[], size_t len, WordTy out[], int shift)
  ```

- 所在命名空间：`HyperInt::Arithmetic`

- 输入和输出如下：

  - 输入参数：
    1. `const WordTy in[]`：输入数组，表示需要左移的多精度整数。
    2. `size_t len`：输入数组的长度（元素个数）。
    3. `int shift`：每个字内需要左移的位数（0 < shift < 字长）。
  - 输出参数：
    1. `WordTy out[]`：输出数组，存放左移后的结果，长度应为 `len + 1`，高位进位会写入 `out[len]`。

- 该模板函数对多精度整数的每个字进行左移操作，并将进位补到更高位，最终结果写入 `out`，最高位进位写在 `out[len]`。请注意，请保证`shift`为正值且不超过输入数组的字长。断言如下：

  ```cpp
  assert(shift >= 0 && size_t(shift) < sizeof(WordTy) * CHAR_BIT);
  ```

  且注意，该数组将不会对`out`数组进行越界检查！

- 推荐调用格式：

  ```cpp
  uint32_t in[3] = { 0xffffffff, 0xffffffff, 0xaaffffff };
  uint32_t out[4] = { 0 };
  int shift = 8;
  HyperInt::Arithmetic::lshift_in_word(in, 3, out, shift);
  // out[0..3] 为左移结果
  // ffffff00 ffffffff ffffffff aa
  ```
---

- **函数名称：**`rshift_in_word`

- 定义方式：

  ```cpp
  template <typename WordTy>
  constexpr void rshift_in_word(const WordTy in[], size_t len, WordTy out[], int shift)
  ```

- 所在命名空间：`HyperInt::Arithmetic`

- 输入和输出如下：

  - 输入参数：
    1. `const WordTy in[]`：输入数组，表示需要右移的多精度整数。
    2. `size_t len`：输入数组的长度（元素个数）。
    3. `int shift`：每个字内需要右移的位数（0 < shift < 字长）。
  - 输出参数：
    1. `WordTy out[]`：输出数组，存放右移后的结果，长度应为 `len`。

- 该模板函数对多精度整数的每个字进行右移操作，并将进位补到更低位，最终结果写入 `out`。请注意，请保证`shift`为正值且不超过输入数组的字长。断言如下：

  ```cpp
  assert(shift >= 0 && size_t(shift) < sizeof(WordTy) * CHAR_BIT);
  ```

  且注意，该数组将不会对`out`数组进行越界检查！

- 推荐调用格式：

  ```cpp
  uint32_t in[3] = { 0x12345678, 0x9ABCDEF0, 0x0FEDCBA9 };
  uint32_t out[3] = { 0 };
  int shift = 8;
  HyperInt::Arithmetic::rshift_in_word(in, 3, out, shift);
  // out[0..2] 为右移结果
  // F0123456 A99ABCDE FEDCB
  ```

---

### 2.2.2 获取非前导零长度

- **函数名称：**`remove_leading_zeros`

- 定义方式：

  ```cpp
  template <typename T>
  inline constexpr size_t remove_leading_zeros(const T array[], size_t length)
  ```

- 所在命名空间：`HyperInt::Arithmetic`

- 输入和输出如下：

  - 输入参数：
    1. `const T array[]`：输入数组，表示多精度整数的各个字（高位在后）。
    2. `size_t length`：输入数组的长度。
  - 输出参数（返回值）：
    1. `size_t`：去除高位前导零后的实际有效长度。

- 该模板函数用于去除多精度整数数组的高位前导零，返回去除后的实际长度。如果数组为空指针，则返回 0。不会修改原数组内容。请注意，输入的`len`将不会进行越界检查，我们将会从下标为`len - 1`位置处开始遍历。

- 推荐调用格式：
  ```cpp
  uint64_t arr[5] = {1, 2, 0, 0, 0};
  size_t len = 5;
  len = HyperInt::Arithmetic::remove_leading_zeros(arr, len);
  // len 现在为2
  ```

---

### 2.2.3 高精度加法计算

- **函数名称：**`abs_add_binary`

- 定义方式：

  ```cpp
  template <typename UintTy>
  constexpr void abs_add_binary(const UintTy a[], size_t len_a, const UintTy b[], size_t len_b, UintTy sum[])
  ```

- 所在命名空间：`HyperInt::Arithmetic`

- 输入和输出如下：

  - 输入参数：
    1. `const UintTy a[]`：加数 a 的数组表示。
    2. `size_t len_a`：a 数组的长度。
    3. `const UintTy b[]`：加数 b 的数组表示。
    4. `size_t len_b`：b 数组的长度。
  - 输出参数：
    1. `UintTy sum[]`：结果数组，长度应为 `max(len_a, len_b) + 1`，高位进位写入 `sum[max(len_a, len_b)]`。

- 该模板函数实现多精度无符号整数的绝对值二进制加法（`a + b`），结果写入`sum`，最高位进位写在`sum[max(len_a, len_b)]`。不会对`sum`数组越界检查！

- 推荐调用格式：

  ```cpp
  uint32_t a[2] = {0xffffffff, 0xffffffff};
  uint32_t b[1] = {0x00000001};
  uint32_t sum[3] = {0};
  HyperInt::Arithmetic::abs_add_binary(a, 2, b, 1, sum);
  // sum[0..3] 为加法结果
  // 0x00000000 0x00000000 0x00000001
  ```

- **函数名称：**`abs_add_base`

- 定义方式：

  ```cpp
  template <typename UintTy>
  constexpr void abs_add_base(const UintTy a[], size_t len_a, const UintTy b[], size_t len_b, UintTy sum[], UintTy base_num)
  ```

- 所在命名空间：`HyperInt::Arithmetic`

- 输入和输出如下：

  - 输入参数：
    1. `const UintTy a[]`：加数 a 的数组表示。
    2. `size_t len_a`：a 数组的长度。
    3. `const UintTy b[]`：加数 b 的数组表示。
    4. `size_t len_b`：b 数组的长度。
    5. `UintTy base_num`：进位基数（每一位的进制）。
  - 输出参数：
    1. `UintTy sum[]`：结果数组，长度应为 `max(len_a, len_b) + 1`，高位进位写入 `sum[max(len_a, len_b)]`。

- 该模板函数实现多精度无符号整数的进制加法（`a + b`，按`base_num`进位），结果写入`sum`，最高位进位写在`sum[max(len_a, len_b)]`。不会对`sum`数组越界检查。请注意，请保证`a`、`b`数组中的每个元素都不超过`base_num`，断言如下：

  ```cpp
  assert( x < base_num && y < base_num);
  //x,y分别为a,b数组中的元素
  ```

- 推荐调用格式：

  ```cpp
  uint64_t a[2] = {9, 9};
  uint64_t b[1] = {1};
  uint64_t sum[3] = {0};
  uint64_t base = 10;
  HyperInt::Arithmetic::abs_add_base(a, 2, b, 1, sum, base);
  // sum[0..3] 为加法结果（按 base 进制进位）
  // 0 0 1
  ```

---
