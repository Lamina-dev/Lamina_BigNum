/*
 * [LAMINA_SCI_CAL]
 * Copyright (C) [2025] [HJimmyK/LAMINA]
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */
/*
MIT License

Copyright (c) 2024-2050 Twilight-Dream & With-Sky

https://github.com/Twilight-Dream-Of-Magic/
https://github.com/With-Sky

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/
#include "BigFrac.hpp"

namespace __LAMINA::BIGFRAC
{
	using BigInteger = __LAMINA::BIGINT::BigInteger;
	using BigSignedInteger = __LAMINA::BIGINT::BigSignedInteger;

	/*

	Here's the Python code used for the precomputation:
	```python
	import sys

	from decimal import Decimal, getcontext
	from fractions import Fraction

	sys.set_int_max_str_digits(0)

	# Set the precision to 1100 digits (slightly higher than 10000 to avoid rounding issues)
	getcontext().prec = 11000

	# Target decimal precision (we want 1000 digits after the decimal point)
	n = 10000

	# Compute ln(2) using high-precision Decimal
	ln2_decimal = Decimal(2).ln()

	# Construct the denominator as 10^10000
	denominator_10n = Decimal(10) ** n

	# Compute the numerator: ln(2) * 10^10000, rounded to the nearest integer
	numerator_10n = int((ln2_decimal * denominator_10n).to_integral_value(rounding='ROUND_HALF_EVEN'))

	# Optional: Reconstruct the decimal to verify the approximation
	approx_ln2 = Decimal(numerator_10n) / denominator_10n

	# Print the results
	print("Numerator:")
	print(numerator_10n)
	print("\nDenominator:")
	print(f"10^{n}")
	print("\nFirst 100 digits of the approximation:")
	print(str(approx_ln2)[:100])
	```
	*/
	// Old: \frac{6243314768165359}{9007199254740992}
	// 0.69314718055994530941723212145817656807550013436025525412068000949339362196969471560586332699641868...
	inline const BigFraction LOG_E2 = BigFraction
	(
		BigInteger("6931471805599453094172321214581765680755001343602552541206800094933936219696947156058633269964186875420014810205706857336855202357581305570326707516350759619307275708283714351903070386238916734711233501153644979552391204751726815749320651555247341395258829504530070953263666426541042391578149520437404303855008019441706416715186447128399681717845469570262716310645461502572074024816377733896385506952606683411372738737229289564935470257626520988596932019650585547647033067936544325476327449512504060694381471046899465062201677204245245296126879465461931651746813926725041038025462596568691441928716082938031727143677826548775664850856740776484514644399404614226031930967354025744460703080960850474866385231381816767514386674766478908814371419854942315199735488037516586127535291661000710535582498794147295092931138971559982056543928717000721808576102523688921324497138932037843935308877482597017155910708823683627589842589185353024363421436706118923678919237231467232172053401649256872747782344535347648114941864238677677440606956265737960086707625719918473402265146283790488306203306114463007371948900274364396500258093651944304119115060809487930678651588709006052034684297361938412896525565396860221941229242075743217574890977067526871158170511370091589426654785959648906530584602586683829400228330053820740056770530467870018416240441883323279838634900156312188956065055315127219939833203075140842609147900126516824344389357247278820548627155274187724300248979454019618723398086083166481149093066751933931289043164137068139777649817697486890388778999129650361927071088926410523092478391737350122984242049956893599220660220465494151061391878857442455775102068370308666194808964121868077902081815885800016881159730561866761991873952007667192145922367206025395954365416553112951759899400560003665135675690512459268257439464831683326249018038242408242314523061409638057007025513877026817851630690255137032340538021450190153740295099422629957796474271381573638017298739407042421799722669629799393127069357472404933865308797587216996451294464918837711567016785988049818388967841349383140140731664727653276359192335112333893387095132090592721854713289754707978913844454666761927028855334234298993218037691549733402675467588732367783429161918104301160916952655478597328917635455567428638774639871019124317542558883012067792102803412068797591430812833072303008834947057924965910058600123415617574132724659430684354652111350215443415399553818565227502214245664400062761833032064727257219751529082785684213207959886389672771195522188190466039570097747065126195052789322960889314056254334425523920620303439417773579455921259019925591148440242390125542590031295370519220615064345837878730020354144217857580132364516607099143831450049858966885772221486528821694181270488607589722032166631283783291567630749872985746389282693735098407780493950049339987626475507031622161390348452994249172483734061366226383493681116841670569252147513839306384553718626877973288955588716344297562447553923663694888778238901749810273565524050518547730619440524232212559024833082778888890596291197299545744156245124859268311260746797281638090250005655999146128332543581114048482060640824224792403855764762350311003242597091425011146155848306700125831821915347207474111940098355732728261442738213970704779562596705790230338480617134555536855375810657497344479225111965461618278960100685129653954796586637835224736245460935850360506784143911445231457780335917921127955705055554514387888188153519485934467246429498640506265184244753956637833734822075332944813064933603546101017746493267877167198612073968320123596077290246830459403130563776313240108042028543590269450940307400149339507673160285028697303187182399843352574354995608502566089783395564211494807339362607510238183314110047089039501343302974134748405406158775396888381540769801776730369991074924697847843128430364112892028012272563468391623354787727340063958657179819069358127387034335313189050383845616444442927969063837969092441303965600987663584627766076053486974908593811939309251791198855527765356660762439356877194233166642838200744816307865229235659826586275918747520875091447609016973569357231824249919475494431631463392270743244590302482544412490359409900711377326310998077723937579092667787226299567773759125268754691760395501473633737461645076457771598146610758399303043231349496586482284678495247540297968900151098424340816722641053465175318895709341462658913980173123676248874585502699619246678052425882378995907144185753559519019313826275593500184826081076906494067924435885831503526017045009346714087384727895167845415252267023696905468698446072109821774736606547523242089063817688335653308345429052023662173681689021810091859270116416256337109210919193811088408371995494139528087438476593315164645244837143495547071767478644667777773262400599442803883005052063960254487221940100482456835584914116372021650148290488954105485988582139146739280127960783765798030190197895831298445842350551628047138457098367143179598497983384936643051357439778464080283944996492836177201217529719601115189233475664664487214704005952700208247971196291259570791322875250242252752285663130430511219493771542940710492247147978154532985068822892694882234218141773477912289705930385167864412351277321379947051313086561526091767421412897899794277108410495559054929958460312928956410723379347221982629602465778859855649153542526276936457817157687505627695951940614769513362135896621103672390186183449100847056023240885740736498064913350497727229854121559922564905903204165800777130365484448790985802916806772298738484805391437126882845158996289290464953606976491322649729017581046490396601249026809144226696306532240532793180520138990302506701645946145093278991874975058845950892812313146535841156454786288876711792759444189103227033972699410782620949066939193233649528840398410534174131030284298298384597274509689153505229806232440923138110578435654734098675193838607282407897523799065221536828449641519520436143002340641177671720819470742812470616078679139714257561026877325672566518779398869543561247252503824110532837942494962425075385985566130187632566463726695281899182447028336064458337646946313432313914423530118060852644531774177829165319868877107483800215964071937546885362724120722736141210013984094390772718393471792022895741896562095677977039547595272233827891909436958956141581883760856034834063384906401173599284897189611655350881207229167416716902882811061704372980788755174869275740035755306007315351924334950734050193793931810588767452835236416527690371651749224459625244061326021533148024272969622677771345064205355151024831061088767266294511910945817001717135117299890025904644763066359724199051847024911088680124694191549654441175995933753867861532885105055485957519052829926745974805776695003496600239248911757605776389825650559728570971462382136461281575699631424743375953147095068089204461516870319405483113785049768421845778096360358356776814229804015130588032213887006143666466195154562642826797900580907023312944256272924492983069495929158131775714230468246948685772631408192667492977253974375636520310755620276511754740767284532831999750648553715678521340479205266153502615115035640625189174989835252957607118611897031987583795086582124471448554809890971322784110436163215054456189256415686480097687527172793631662356769343050705400960785297576973347816339786503563447596083113058918741088775476498966140767093540099289679033005197129229294655908813155093792311652676248200974255320501351088304034115018668628172784448518320999893113810480114847364338261550474827000102727871555379607626977726233061428597322037017716488013935906731651593131207225660010057306787815875968237327432664863152551632539069522055152460415473672664715829719759100176329246755391947924412596855986918431266716876066114774212493131547577111029905275698849479218285429200771991138110640201310850296702223726371927432520508605883939945814143535946600955513703685151439534425132251623274481769284748335160181431483775772910265977050216375513317616320906962102363852706627337362690153696255073610884241576308151549058618960450223864851723710305700902066826458514960037828134831228854708597775562195752286969914671954540310816696269690296896222715552668123003336549928427924612250395570999614692971694339351544508557516142866963351826393901192551987712707669409200410842997382985072562990345850433584478193617497687963688481517014603841493189458567310955889799384166616697431842151088678182747274771922062439778066084664630977888195315596103595567520455859572036591635522582959536734037782112409893988073073541836213121088375170380368236163604481832644531771086739357751041914220906966917822647476248726919802612861083744865233044185807437406799924659359146430681924558555771836314041797245925837265876930872766629910804504348591495996962501941052691904827629968903003602357636424254397670564582540996414041450994670345387743125702655292199608428211070672039110526250561980914926429443191308362902026158372172207479904166903500594072814160493965365572734122339332806103370037021008211534192227293534916762079885625851679806479158586942391146178726357859291357726649656033071530623284906061534893403415083718713352615870286424651827290435568456552106161725177136625005254799445985467661817786025877803806030984445445231764300573378558790455136113162544138851136958094835849584914934421251105356131748993037427322843117221670118781585253525367038010852035298366282616347129789683306531521000247432193921670599073133403022837905315374833325886025968671733006730262612955255637933976817300485239406795549141449465881533293253950529298238146676292254117063142342669344856493368632531418747139643415905283733805759990776658169381718971757458617472391097384196997646199589679391854451098059585787249716421848244964174409657751106908793193517216376221168703906403811218433433897183542006078817356825697886748930465585244588375921264841779920836375927805215882886594444347071772120467466371740330707609189137396956143477741839440991803548117653335878130833510705646029925695615913401856601359655561"),
		BigInteger("1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"),
		1
	);

	BigFraction::BigFraction() : numerator(0), denominator(1), sign(1) {}

	BigFraction::BigFraction(const BigFraction& other) noexcept
		: numerator(other.numerator), denominator(other.denominator), sign(other.sign),
		simplify_reduced(other.simplify_reduced),
		PrecisionMode(other.PrecisionMode), FixedPrecisionCount(other.FixedPrecisionCount)
	{
	}

	BigFraction::BigFraction(BigFraction&& other) noexcept
		: numerator(other.numerator), denominator(other.denominator), sign(other.sign),
		simplify_reduced(other.simplify_reduced),
		PrecisionMode(other.PrecisionMode), FixedPrecisionCount(other.FixedPrecisionCount)
	{
	}

	BigFraction::BigFraction(const BigInteger& numerator)
		: numerator(numerator), denominator(1), sign(1) {
	}

	BigFraction::BigFraction(const BigInteger& numerator, const BigInteger& denominator)
		: numerator(numerator), denominator(denominator), sign(1)
	{
		if (simplify_reduced)
		{
			this->ReduceSimplify();
		}
	}

	BigFraction::BigFraction(const BigInteger& numerator, const BigInteger& denominator, int32_t sign)
		: numerator(numerator), denominator(denominator), sign(sign)
	{
		if (simplify_reduced)
		{
			this->ReduceSimplify();
		}

		this->sign = (this->sign >= 0 ? 1 : -1);
	}

	BigFraction::BigFraction(const std::string& complexString)
	{
		ComputeAndFromDecimalString(complexString);
	}

	void BigFraction::SetSimplifyReduced(bool value)
	{
		simplify_reduced = value;
	}

	bool BigFraction::IsNaN() const
	{
		if (numerator.IsZero() && denominator.IsZero())
		{
			return true;
		}

		return false;
	}

	bool BigFraction::IsInfinityPoint() const
	{
		if (!numerator.IsZero() && denominator.IsZero())
		{
			return true;
		}

		return false;
	}

	bool BigFraction::IsZero() const
	{
		return numerator.IsZero() && !denominator.IsZero();
	}

	bool BigFraction::IsNegative() const
	{
		return sign == -1;
	}

	bool BigFraction::IsInteger() const
	{
		BigFraction copy = *this;
		copy.ReduceSimplify();

		return copy.numerator == 1;
	}

	BigFraction::BigInteger BigFraction::GetNumerator() const
	{
		return numerator;
	}

	BigFraction::BigInteger BigFraction::GetDenominator() const
	{
		return denominator;
	}

	std::optional<BigInteger> BigFraction::TryGetInteger() const
	{
		if (IsInteger())
		{
			return numerator;
		}
		if (!IsNaN())
		{
			return numerator / denominator;
		}
		return std::nullopt;
	}

	void BigFraction::SetNumerator(const BigInteger& number)
	{
		numerator = number;
	}

	void BigFraction::SetDenominator(const BigInteger& number)
	{
		denominator = number;
	}

	BigFraction BigFraction::GetFullPrecision() const
	{
		return BigFractionFullPrecision;
	}

	void BigFraction::SetFullPrecision(BigInteger number)
	{
		if (number.IsZero())
		{
			if (this->PrecisionMode != DecimalPrecisionMode::Full)
				return;
			else
				throw std::invalid_argument("BigFractionFullPrecision Undefined: a denominator that is 0 is incorrect.");
		}

		if (!((number % TEN).IsZero()))
		{
			throw std::invalid_argument("BigFractionFullPrecision Undefined: denominators that are not multiples of 10 are incorrect.");
		}

		// Ensure that number is of the form 10^n
		BigInteger temp = number;
		while ((temp % TEN).IsZero())
		{
			temp /= TEN;
		}

		// After division, if temp is not 1, then number was not 10^n
		if (temp != BigInteger(1))
		{
			throw std::invalid_argument("BigFractionFullPrecision Undefined: denominator must be a power of 10.");
		}

		this->PrecisionMode = DecimalPrecisionMode::Full;

		// Set the denominator of BigFractionFullPrecision to number
		BigFractionFullPrecision.SetNumerator(1);
		BigFractionFullPrecision.SetDenominator(number);

		// Check if the denominator is not zero before setting
		if (BigFractionFullPrecision.GetDenominator().IsZero())
		{
			throw std::invalid_argument("BigFractionFullPrecision Undefined: a denominator that is 0 is incorrect.");
		}
	}

	void BigFraction::ComputeAndFromDecimalString(const std::string& complexString)
	{
		// Parsing Complex String
		bool   isNegative = false;
		bool   hasFractionalPart = false;
		size_t integerPartEnd = 0;
		size_t fractionalPartStart = 0;

		// Determine if the number is negative
		if (!complexString.empty() && complexString[0] == '-')
		{
			isNegative = true;
			integerPartEnd = 1;
		}

		// Find the end of integer part
		while (integerPartEnd < complexString.size() && std::isdigit(complexString[integerPartEnd]))
		{
			integerPartEnd++;
		}

		// Check if there is a fractional part
		if (integerPartEnd < complexString.size() && complexString[integerPartEnd] == '.')
		{
			hasFractionalPart = true;
			fractionalPartStart = integerPartEnd + 1;
		}

		// Parse integer part
		BigInteger integerPart(complexString.substr(isNegative, integerPartEnd - isNegative));

		// Parse fractional part if exists
		BigInteger fractionalPart = 0;
		BigInteger fractionalMultiplier = 1;
		if (hasFractionalPart)
		{
			uint64_t LoopCount = 0;

			switch (this->PrecisionMode)
			{
			case DecimalPrecisionMode::Fixed:
				LoopCount = this->FixedPrecisionCount;
				break;
			case DecimalPrecisionMode::Full:
				LoopCount = complexString.size();
				break;
			default:
				break;
			}

			for (size_t i = fractionalPartStart; i < LoopCount; ++i)
			{
				if (!std::isdigit(complexString[i]))
				{
					// Invalid character found in fractional part
					// You may want to handle this error case appropriately
					return;
				}
				fractionalPart = fractionalPart * RADIX + (complexString[i] - '0');
				fractionalMultiplier *= RADIX;
			}
		}

		// Combine integer and fractional parts into the numerator
		numerator = integerPart * fractionalMultiplier + fractionalPart;
		denominator = fractionalMultiplier;

		// Apply the sign
		if (isNegative)
		{
			numerator *= -1;
		}

		// Simplify the fraction to reduce it to its simplest form
		if (simplify_reduced)
		{
			ReduceSimplify();
		}
	}

	std::string BigFraction::ComputeAndToDecimalString() const
	{
		if (IsNaN())
		{
			return "NaN";
		}

		std::string signString = (sign == -1) ? "-" : "";

		BigFraction abs = this->Abs();
		BigInteger absNumerator = abs.GetNumerator();
		BigInteger absDenominator = abs.GetDenominator();

		// Reduce the fraction to its simplest form if necessary
		if (absNumerator > 1 && absDenominator > 1)
		{
			BigInteger gcd = BigInteger::GCD(absNumerator, absDenominator);
			absNumerator /= gcd;
			absDenominator /= gcd;
		}

		// Compute the integer part
		BigInteger	integerPart = absNumerator / absDenominator;
		std::string result = signString + integerPart.ToString(10) + ".";

		switch (this->PrecisionMode)
		{
		case DecimalPrecisionMode::Fixed:
		{
			if (this->FixedPrecisionCount == 0)
			{
				// Return only the integer part
				result += "0";
				return result;
			}

			BigInteger fractionalPart = absNumerator % absDenominator;
			for (size_t i = 0; i < this->FixedPrecisionCount; ++i)
			{
				fractionalPart *= RADIX;
				BigInteger nextDigit = fractionalPart / absDenominator;
				fractionalPart %= absDenominator;
				result += nextDigit.ToString(10);
				if (fractionalPart == 0)
				{
					// Stop if the fractional part becomes zero before reaching the desired precision
					break;
				}
			}

			break;
		}

		case DecimalPrecisionMode::Full:
		{
			if (absDenominator.IsZero())
			{
				throw std::invalid_argument("Denominator cannot be zero.");
			}

			BigInteger fractionalPart = absNumerator % absDenominator;
			BigFraction precision = GetFullPrecision(); // Assume GetFullPrecision() returns the minimal precision as a fraction

			// Determine the required decimal precision based on the denominator of the precision fraction.
			// We will count how many times the denominator can be divided by 10 (RADIX).
			BigInteger precisionDenominator = precision.GetDenominator();
			BigInteger requiredPrecisionCount = 0;

			// Count the number of decimal places needed by repeatedly dividing the precision denominator by RADIX (10).
			while ((precisionDenominator % RADIX).IsZero())
			{
				precisionDenominator /= RADIX;
				requiredPrecisionCount++;
			}

			bool hasFractionalPart = false;  // Flag to indicate if there is a fractional part

			// Generate the decimal representation by calculating each digit up to the required precision.
			for (BigInteger i = 0; i < requiredPrecisionCount; ++i)
			{
				if (fractionalPart == 0)
				{
					break; // The fractional part has been completely consumed, no more digits needed
				}

				hasFractionalPart = true;
				fractionalPart *= RADIX; // Shift the fractional part to the next decimal place
				BigInteger nextDigit = fractionalPart / absDenominator;
				fractionalPart %= absDenominator; // Update the fractional part for the next iteration
				result += nextDigit.ToString(10); // Append the next digit to the result string
			}

			// If no fractional digits were added, append a '0' to ensure proper decimal formatting (e.g., "1.0").
			if (!hasFractionalPart)
			{
				result += "0";
			}

			break;
		}
		default:
			break;
		}

		return result;
	}

	BigFraction& BigFraction::operator=(const BigFraction& other)
	{
		if (this != &other)
		{
			this->numerator = other.numerator;
			this->denominator = other.denominator;
			this->sign = other.sign;
			this->simplify_reduced = this->simplify_reduced;
			this->PrecisionMode = other.PrecisionMode;
			this->FixedPrecisionCount = other.FixedPrecisionCount;
		}
		return *this;
	}

	BigFraction& BigFraction::operator=(BigFraction&& other)
	{
		if (this != &other)
		{
			this->numerator = std::move(other.numerator);
			this->denominator = std::move(other.denominator);
			this->sign = std::move(other.sign);
			this->simplify_reduced = std::move(this->simplify_reduced);
			this->PrecisionMode = std::move(other.PrecisionMode);
			this->FixedPrecisionCount = std::move(other.FixedPrecisionCount);
		}
		return *this;
	}

	BigFraction& BigFraction::operator+=(const BigFraction& other)
	{
		if (this->IsNaN() || other.IsNaN())
		{
			this->sign = 1;
			this->numerator = 0;
			this->denominator = 1;
			return *this;
		}

		if (IsZero())
		{
			if (other.IsZero())
			{
				sign = 1;
				numerator = 0;
				denominator = 1;
				return *this;
			}
			else if (other.IsNegative())
			{
				sign = -1;
				numerator = other.numerator.Abs();
				denominator = other.denominator.Abs();
				return *this;
			}
			else
			{
				sign = 1;
				numerator = other.numerator.Abs();
				denominator = other.denominator.Abs();
				return *this;
			}
		}
		else if (other.IsZero())
		{
			return *this;
		}

		// Use BigSignedInteger for intermediate calculations
		BigSignedInteger a(this->numerator * other.denominator, this->sign < 0);
		BigSignedInteger b(other.numerator * this->denominator, other.sign < 0);
		BigSignedInteger resultNumeratorSigned = a + b;
		BigInteger resultDenominatorSigned = this->denominator * other.denominator;

		// Determine the sign and absolute values
		sign = resultNumeratorSigned.IsNegative() ? -1 : 1;
		numerator = static_cast<BigInteger>(resultNumeratorSigned.Abs());
		denominator = resultDenominatorSigned;

		if (simplify_reduced)
		{
			ReduceSimplify();
		}

		return *this;
	}

	BigFraction& BigFraction::operator+=(const BigInteger& other)
	{
		if (this->IsNaN())
		{
			this->sign = 1;
			this->numerator = 0;
			this->denominator = 1;
			return *this;
		}

		if (this->IsZero())
		{
			this->sign = 1;
			this->numerator = other;
			this->denominator = 1;
			return *this;
		}
		else if (other.IsZero())
		{
			return *this;
		}

		// Use BigSignedInteger for intermediate calculations
		BigSignedInteger a(this->numerator, this->sign < 0);
		BigSignedInteger b(other, false);  // other is always positive

		BigSignedInteger resultNumeratorSigned;
		if (this->sign == 1)
		{
			resultNumeratorSigned = a + b;
		}
		else
		{
			resultNumeratorSigned = a - b;
		}

		// Determine the sign and absolute values
		sign = resultNumeratorSigned.IsNegative() ? -1 : 1;
		numerator = static_cast<BigInteger>(resultNumeratorSigned.Abs());
		// Denominator remains unchanged

		if (simplify_reduced)
		{
			ReduceSimplify();
		}

		return *this;
	}

	BigFraction& BigFraction::operator-=(const BigFraction& other)
	{
		if (this->IsNaN() || other.IsNaN())
		{
			this->sign = 1;
			this->numerator = 0;
			this->denominator = 1;
			return *this;
		}

		if (this->IsZero())
		{
			if (other.IsZero())
			{
				this->sign = 1;
				this->numerator = 0;
				this->denominator = 1;
				return *this;
			}
			else if (other.IsNegative())
			{
				this->sign = 1;
				this->numerator = other.numerator.Abs();
				this->denominator = other.denominator.Abs();
				return *this;
			}
			else
			{
				this->sign = -1;
				this->numerator = other.numerator.Abs();
				this->denominator = other.denominator.Abs();
				return *this;
			}
		}
		else if (other.IsZero())
		{
			return *this;
		}

		// Use BigSignedInteger for intermediate calculations
		BigSignedInteger a(this->numerator * other.denominator, this->sign < 0);
		BigSignedInteger b(other.numerator * this->denominator, other.sign < 0);
		BigSignedInteger resultNumeratorSigned = a - b;
		BigInteger resultDenominator = this->denominator * other.denominator;

		// Determine the sign and absolute values
		sign = resultNumeratorSigned.IsNegative() ? -1 : 1;
		numerator = static_cast<BigInteger>(resultNumeratorSigned.Abs());
		denominator = resultDenominator.Abs();

		if (simplify_reduced)
		{
			ReduceSimplify();
		}

		return *this;
	}

	BigFraction& BigFraction::operator-=(const BigInteger& other)
	{
		if (this->IsNaN())
		{
			this->sign = 1;
			this->numerator = 0;
			this->denominator = 1;
			return *this;
		}

		if (this->IsZero())
		{
			if (other.IsZero())
			{
				this->sign = 1;
				this->numerator = 0;
				this->denominator = 1;
				return *this;
			}
			else if (other.IsNegative())
			{
				this->sign = 1;
				this->numerator = other.Abs();
				this->denominator = 1;
				return *this;
			}
			else
			{
				this->sign = -1;
				this->numerator = other;
				this->denominator = 1;
				return *this;
			}
		}
		else if (other.IsZero())
		{
			return *this;
		}

		// Use BigSignedInteger for intermediate calculations
		BigSignedInteger a(this->numerator, this->sign < 0);
		BigSignedInteger b(other, false);

		BigSignedInteger resultNumeratorSigned;
		if ((this->sign > 0) || (this->sign < 0))
		{
			resultNumeratorSigned = a + b.Abs();
		}
		else
		{
			resultNumeratorSigned = a - b;
		}

		// Determine the sign and absolute values
		sign = resultNumeratorSigned.IsNegative() ? -1 : 1;
		numerator = static_cast<BigInteger>(resultNumeratorSigned.Abs());
		// Denominator remains unchanged

		if (simplify_reduced)
		{
			ReduceSimplify();
		}

		return *this;
	}

	BigFraction& BigFraction::operator*=(const BigFraction& other)
	{
		if (this->IsNaN() || other.IsNaN())
		{
			this->sign = 1;
			this->numerator = 0;
			this->denominator = 1;
			return *this;
		}

		if (other.IsZero())
		{
			this->sign = 1;
			this->numerator = 0;
			this->denominator = 1;
			return *this;
		}
		if ((other.numerator > 0 && other.denominator > 0) && (other.numerator == other.denominator))
		{
			return *this;
		}

		// Use BigSignedInteger for intermediate calculations
		BigSignedInteger signed_numerator(this->numerator, this->sign < 0);
		BigSignedInteger signed_denominator(this->denominator, this->sign < 0);
		BigSignedInteger other_signed_numerator(other.numerator, other.IsNegative());
		BigSignedInteger other_signed_denominator(other.denominator, other.IsNegative());

		signed_numerator *= other_signed_numerator;
		signed_denominator *= other_signed_denominator;

		this->sign = (signed_numerator.IsNegative() != other_signed_denominator.IsNegative()) ? -1 : 1;
		this->numerator = static_cast<BigInteger>(signed_numerator.Abs());
		this->denominator = static_cast<BigInteger>(signed_denominator.Abs());

		if (simplify_reduced)
		{
			ReduceSimplify();
		}

		return *this;
	}

	BigFraction& BigFraction::operator*=(const BigInteger& other)
	{
		if (other.IsZero())
		{
			this->sign = 1;
			this->numerator = 0;
			this->denominator = 1;
			return *this;
		}
		if (other == 1)
		{
			return *this;
		}

		// Use BigSignedInteger for intermediate calculations
		BigSignedInteger signed_numerator(this->numerator, this->sign < 0);
		BigSignedInteger signed_other(other, false);

		signed_numerator *= signed_other;

		this->numerator = static_cast<BigInteger>(signed_numerator.Abs());
		this->sign = signed_numerator.IsNegative() ? -1 : 1;

		if (simplify_reduced)
		{
			ReduceSimplify();
		}

		return *this;
	}

	BigFraction& BigFraction::operator/=(const BigFraction& other)
	{
		if (this->IsNaN() || other.IsNaN())
		{
			this->sign = 1;
			this->numerator = 0;
			this->denominator = 1;
			return *this;
		}

		if (other.denominator.IsZero())
		{
			throw std::runtime_error("Division by zero error.");
		}

		// Use BigSignedInteger for intermediate calculations
		BigSignedInteger signed_numerator(this->numerator, this->sign < 0);
		BigSignedInteger signed_denominator(this->denominator, this->sign < 0);
		BigSignedInteger other_signed_numerator(other.numerator, other.IsNegative());
		BigSignedInteger other_signed_denominator(other.denominator, other.IsNegative());

		signed_numerator *= other_signed_denominator; // Multiply the numerator by the denominator of another fraction
		signed_denominator *= other_signed_numerator; // Multiply the denominator by the numerator of another fraction

		this->sign = (signed_numerator.IsNegative() != signed_denominator.IsNegative()) ? -1 : 1;
		this->numerator = static_cast<BigInteger>(signed_numerator.Abs());
		this->denominator = static_cast<BigInteger>(signed_denominator.Abs());

		if (simplify_reduced)
		{
			ReduceSimplify();
		}

		return *this;
	}

	BigFraction& BigFraction::operator/=(const BigInteger& other)
	{
		if (this->IsNaN())
		{
			this->sign = 1;
			this->numerator = 0;
			this->denominator = 1;
			return *this;
		}

		if (other.IsZero())
		{
			throw std::runtime_error("Division by zero error.");
		}

		// 使用 BigSignedInteger 进行中间计算
		BigSignedInteger signed_numerator(this->numerator, this->sign < 0);
		BigSignedInteger signed_denominator(this->denominator, this->sign < 0);
		BigSignedInteger other_signed(other, false);

		signed_denominator *= other_signed;

		this->sign = (signed_numerator.IsNegative() != signed_denominator.IsNegative()) ? -1 : 1;
		this->numerator = static_cast<BigInteger>(signed_numerator.Abs());
		this->denominator = static_cast<BigInteger>(signed_denominator.Abs());

		if (simplify_reduced)
		{
			ReduceSimplify();
		}

		return *this;
	}

	BigFraction BigFraction::operator+(const BigFraction& other) const
	{
		BigFraction result(*this);
		result += other;

		result.PrecisionMode = this->PrecisionMode;
		result.FixedPrecisionCount = this->FixedPrecisionCount;

		return result;
	}

	BigFraction BigFraction::operator+(const BigInteger& other) const
	{
		BigFraction result(*this);
		result += other;

		result.PrecisionMode = this->PrecisionMode;
		result.FixedPrecisionCount = this->FixedPrecisionCount;

		return result;
	}

	BigFraction BigFraction::operator-(const BigFraction& other) const
	{
		BigFraction result(*this);
		result -= other;

		result.PrecisionMode = this->PrecisionMode;
		result.FixedPrecisionCount = this->FixedPrecisionCount;

		return result;
	}

	BigFraction BigFraction::operator-(const BigInteger& other) const
	{
		BigFraction result(*this);
		result -= other;

		result.PrecisionMode = this->PrecisionMode;
		result.FixedPrecisionCount = this->FixedPrecisionCount;

		return result;
	}

	BigFraction BigFraction::operator*(const BigFraction& other) const
	{
		BigFraction result(*this);
		result *= other;

		result.PrecisionMode = this->PrecisionMode;
		result.FixedPrecisionCount = this->FixedPrecisionCount;

		return result;
	}

	BigFraction BigFraction::operator*(const BigInteger& other) const
	{
		BigFraction result(*this);
		result *= other;

		result.PrecisionMode = this->PrecisionMode;
		result.FixedPrecisionCount = this->FixedPrecisionCount;

		return result;
	}

	BigFraction BigFraction::operator/(const BigFraction& other) const
	{
		BigFraction result(*this);
		result /= other;

		result.PrecisionMode = this->PrecisionMode;
		result.FixedPrecisionCount = this->FixedPrecisionCount;

		return result;
	}

	BigFraction BigFraction::operator/(const BigInteger& other) const
	{
		BigFraction result(*this);
		result /= other;

		result.PrecisionMode = this->PrecisionMode;
		result.FixedPrecisionCount = this->FixedPrecisionCount;

		return result;
	}

	BigFraction BigFraction::operator-() const
	{
		BigFraction result(*this);
		result.sign = -result.sign;
		return result;
	}

	bool BigFraction::operator<(const BigFraction& other) const
	{
		BigInteger lhs = numerator * other.denominator;
		BigInteger rhs = other.numerator * denominator;
		return lhs < rhs;
	}

	bool BigFraction::operator<=(const BigFraction& other) const
	{
		return !(*this > other);
	}

	bool BigFraction::operator>(const BigFraction& other) const
	{
		BigInteger lhs = numerator * other.denominator;
		BigInteger rhs = other.numerator * denominator;
		return lhs > rhs;
	}

	bool BigFraction::operator>=(const BigFraction& other) const
	{
		return !(*this < other);
	}

	bool BigFraction::operator==(const BigFraction& other) const
	{
		return numerator == other.numerator && denominator == other.denominator && sign == other.sign;
	}

	bool BigFraction::operator!=(const BigFraction& other) const
	{
		return !(*this == other);
	}

	BigFraction BigFraction::Abs() const
	{
		BigFraction result = BigFraction(numerator, denominator, 1);

		result.PrecisionMode = this->PrecisionMode;
		result.FixedPrecisionCount = this->FixedPrecisionCount;
		return result;
	}

	BigFraction BigFraction::Reciprocal() const
	{
		BigFraction result;

		if (IsNaN())
		{
			result = BigFraction(0, 0);
		}
		else if (IsZero())
		{
			result = BigFraction(0, ONE);
		}
		else
		{
			result = BigFraction(denominator, numerator, sign);
		}

		result.PrecisionMode = this->PrecisionMode;
		result.FixedPrecisionCount = this->FixedPrecisionCount;
		result.sign = this->sign;
		return result;
	}

	BigFraction BigFraction::Sqrt()
	{
		BigFraction result;

		if (IsNaN())
		{
			result = BigFraction(0, ONE);
		}
		else if (IsZero())
		{
			result = BigFraction(0, ONE);
		}
		else if (IsNegative())
		{
			result = BigFraction(0, ONE);
		}
		else
		{
			result = BigFraction(BigInteger(numerator).Sqrt(), BigInteger(denominator).Sqrt());
		}

		result.PrecisionMode = this->PrecisionMode;
		result.FixedPrecisionCount = this->FixedPrecisionCount;
		return result;
	}

	BigFraction BigFraction::Cbrt()
	{
		BigFraction result;

		if (IsNaN())
		{
			result = BigFraction(0, ONE);
		}
		else if (IsZero())
		{
			result = BigFraction(0, ONE);
		}
		else if (IsNegative())
		{
			result = BigFraction(0, ONE);
		}
		else
		{
			result = BigFraction(BigInteger(numerator).Cbrt(), BigInteger(denominator).Cbrt());
		}

		result.PrecisionMode = this->PrecisionMode;
		result.FixedPrecisionCount = this->FixedPrecisionCount;
		return result;
	}

	// Logarithm base e
	BigFraction BigFraction::Log(const BigInteger& value) const
	{
		if (value.IsZero())
		{
			throw std::invalid_argument("Logarithm of non-positive value is undefined.");
		}

		BigFraction result = LogarithmCF(value);

		result.PrecisionMode = this->PrecisionMode;
		result.FixedPrecisionCount = this->FixedPrecisionCount;
		return result;
	}

	BigFraction BigFraction::Log() const
	{
		if (IsZero() || IsNegative())
		{
			throw std::invalid_argument("Logarithm of non-positive value is undefined.");
		}
		BigFraction numeratorLog = LogarithmCF(this->numerator);
		BigFraction denominatorLog = LogarithmCF(this->denominator);
		BigFraction result = numeratorLog - denominatorLog;

		result.PrecisionMode = this->PrecisionMode;
		result.FixedPrecisionCount = this->FixedPrecisionCount;
		return result;
	}

	// Logarithm base 10
	BigFraction BigFraction::Log10(const BigInteger& fraction) const
	{
		static const BigFraction LOG_10_E = Log(TEN);
		BigFraction result = LogarithmCF(fraction) / LOG_10_E;

		result.PrecisionMode = this->PrecisionMode;
		result.FixedPrecisionCount = this->FixedPrecisionCount;
		return result;
	}

	BigFraction BigFraction::Log10() const
	{
		static const BigFraction LOG_10_E = Log(TEN);
		BigFraction result = Log() / LOG_10_E;

		result.PrecisionMode = this->PrecisionMode;
		result.FixedPrecisionCount = this->FixedPrecisionCount;
		return result;
	}

	// Exponential function using Taylor series
	BigFraction BigFraction::Exponential_Taylor(const BigInteger& value, DecimalPrecisionMode precision_mode, uint64_t fixed_precision_count)
	{
		BigFraction result(ONE, ONE);
		BigFraction term(ONE, ONE);
		BigInteger i = ONE;

		switch (precision_mode)
		{
		case DecimalPrecisionMode::Fixed:
		{
			for (uint64_t round = fixed_precision_count + 1; round > 0; round--)
			{
				term = term * BigFraction(value, i);
				result += term;
				i += ONE;
			}

			break;
		}

		case DecimalPrecisionMode::Full:
		{
			while (term > BigFractionFullPrecision)
			{
				term = term * BigFraction(value, i);
				result += term;
				i += ONE;
			}

			break;
		}
		default:
			break;
		}

		return result;
	}

	BigFraction BigFraction::Exponential_Taylor(const BigFraction& value)
	{
		BigFraction result(ONE, ONE);
		BigFraction term(ONE, ONE);
		BigInteger i = ONE;

		switch (value.PrecisionMode)
		{
		case DecimalPrecisionMode::Fixed:
		{
			for (uint64_t round = value.FixedPrecisionCount + 1; round > 0; round--)
			{
				term = term * (value / i);
				result += term;
				i += ONE;
			}

			break;
		}

		case DecimalPrecisionMode::Full:
		{
			BigFraction precision = value.GetFullPrecision();
			while (term > precision)
			{
				term = term * (value / i);
				result += term;
				i += ONE;
			}

			break;
		}
		default:
			break;
		}

		result.PrecisionMode = value.PrecisionMode;
		result.FixedPrecisionCount = value.FixedPrecisionCount;

		return result;
	}

	BigFraction BigFraction::Exponential(const BigFraction& x, int64_t precision_digits)
	{
		// Handle special case: e^0 = 1
		if (x.IsZero())
		{
			return BigFraction(1, 1);
		}

		// Determine sign and work with absolute value
		bool isNegative = x.IsNegative();
		BigFraction abs_x = isNegative ? -x : x;

		BigInteger big_ten = BigInteger(10);

		// Step 1: Compute log_e(2) with extra precision to ensure accuracy

		// Step 2: Argument reduction
		// Compute k = floor(abs_x / log_e2)
		BigFraction kFrac = abs_x / LOG_E2;
		BigInteger k = kFrac.Floor();

		// Compute r = abs_x - k * log_e2
		BigFraction r = abs_x - BigFraction(k, 1) * LOG_E2;

		// Step 3: Compute 2^k
		BigFraction two_power_k = BigFraction(BigInteger::TwoPowerN(k.ToUnsignedInt()), BigInteger(1));

		// Step 4: Compute e^r using Taylor series

		// Taylor series: e^r = 1 + r/1! + r^2/2! + r^3/3! + ...
		BigFraction sum = Exponential_Taylor(r);

		// Step 5: Combine results
		BigFraction result = two_power_k * sum;

		// Step 6: Handle negative input
		if (isNegative)
		{
			result = BigFraction(1) / result;
		}

		return result;
	}

	BigFraction BigFraction::Power(const BigInteger& exponent) const
	{
		BigFraction result;

		if (exponent.IsZero())
		{
			result = BigFraction(ONE, ONE);
		}
		else if (exponent > 0)
		{
			BigInteger numeratorPower = numerator;
			numeratorPower.BigPower(exponent);
			BigInteger denominatorPower = denominator;
			denominatorPower.BigPower(exponent);
			result = BigFraction(numeratorPower, denominatorPower);
		}
		else
		{
			result = Reciprocal().Power(exponent);
		}

		result.PrecisionMode = this->PrecisionMode;
		result.FixedPrecisionCount = this->FixedPrecisionCount;
		return result;
	}

	BigFraction BigFraction::Power(const BigFraction& exponent) const
	{
		BigFraction result;

		if (IsNaN())
		{
			result = BigFraction(0, ONE);
		}
		else if (IsZero())
		{
			result = BigFraction(ONE, ONE);
		}
		else if (exponent.IsZero())
		{
			result = BigFraction(ONE, ONE);;
		}
		else if (numerator.IsZero())
		{
			result = BigFraction(0, ONE);
		}
		else
		{
			// If the numerator is greater than or equal to the denominator, the fraction is greater than or equal to 1.
			if (this->numerator >= this->denominator || (this->numerator > ONE && this->denominator == ONE))
			{
				BigFraction newNumerator = Log(numerator) * exponent;
				BigFraction newDenominator = Log(denominator) * exponent;

				BigFraction resultNumerator = Exponential(newNumerator, 16);
				BigFraction resultDenominator = Exponential(newDenominator, 16);

				result = BigFraction(resultNumerator.GetNumerator(), resultDenominator.GetNumerator());
			}
			else
			{
				long double value = static_cast<long double>(*this);
				long double value2 = static_cast<long double>(exponent);
				long double floating_result = std::pow(value, value2);
				BigFraction result = this->FromFloatingNumber<long double>(floating_result);
			}
		}

		result.PrecisionMode = this->PrecisionMode;
		result.FixedPrecisionCount = this->FixedPrecisionCount;
		return result;
	}

	/**
	 * @brief Computes the nth root of a BigFraction.
	 *
	 * This function calculates the nth root of a BigFraction. The approach depends
	 * on whether the fraction's numerator is greater than or equal to the denominator
	 * (i.e., the fraction is greater than or equal to 1) or less than the denominator
	 * (i.e., the fraction is less than 1).
	 *
	 * @param n The root to compute (e.g., n = 2 for square root).
	 * @return BigFraction The nth root of the fraction.
	 * @throws std::invalid_argument if the fraction is zero or negative, as the nth root
	 *         is undefined for these cases.
	 */
	BigFraction BigFraction::NthRoot(const BigInteger& n) const
	{
		// Check for invalid input: zero or negative values are not supported.
		if (IsZero() || IsNegative())
		{
			throw std::invalid_argument("Nth root of zero or negative value is undefined.");
		}

		// Nth Root for BigFraction
		// If the numerator is greater than or equal to the denominator, the fraction is greater than or equal to 1.
		if (this->numerator >= this->denominator || (this->numerator > ONE && this->denominator == ONE))
		{
			// Use the ShiftingKthRoot algorithm to compute the nth root 
			// for both the numerator and denominator.
			__LAMINA::BIGINT::ShiftingKthRoot kthRootCalculator(n.Size());
			__LAMINA::BIGINT::BigInteger kthRootedNumerator = kthRootCalculator(this->numerator);
			__LAMINA::BIGINT::BigInteger kthRootedDenominator = kthRootCalculator(this->denominator);

			// Construct the result as a BigFraction.
			BigFraction result(kthRootedNumerator, kthRootedDenominator);
			result.PrecisionMode = this->PrecisionMode;
			result.FixedPrecisionCount = this->FixedPrecisionCount;
			return result;
		}
		else
		{
			// For small fractions (numerator < denominator), using integer root algorithms can be problematic due to potential precision issues. 
			// Therefore, we convert the fraction to a floating-point number, compute the root, and then convert back to BigFraction.

			// Convert the fraction to a long double for root calculation.
			long double value = static_cast<long double>(*this);
			// Compute the nth root using standard library pow function.
			long double floating_result = std::pow(value, static_cast<long double>(1.0) / n.ToUnsignedInt());
			// Convert the floating-point result back to BigFraction.
			BigFraction result = this->FromFloatingNumber<long double>(floating_result);
			result.PrecisionMode = this->PrecisionMode;
			result.FixedPrecisionCount = this->FixedPrecisionCount;
			return result;
		}

		// This point should not be reached, as the function should return from one of the branches above.
		return BigFraction(ONE, ONE);
	}


	// Nth Root for BigFraction with fraction parameter
	BigFraction BigFraction::NthRoot(const BigFraction& fraction, const BigInteger& nth) const
	{
		if (fraction.IsZero() || fraction.IsNegative())
		{
			throw std::invalid_argument("Nth root of zero or negative value is undefined.");
		}

		auto result = fraction.NthRoot(nth);
		// Return the refined result
		result.PrecisionMode = this->PrecisionMode;
		result.FixedPrecisionCount = this->FixedPrecisionCount;
		return result;
	}

	BigFraction BigFraction::Sine(const BigFraction& x) const
	{
		BigFraction result(0, ONE);
		BigFraction term = x;  // x^1 / 1!
		BigInteger	i = ONE;   // Factorial index starts at 1

		bool isNegative = false;

		switch (this->PrecisionMode)
		{
		case DecimalPrecisionMode::Fixed:
		{
			for (uint64_t round = this->FixedPrecisionCount + 1; round > 0; --round)
			{
				if (isNegative)
				{
					result -= term;
				}
				else
				{
					result += term;
				}

				// Prepare for the next term: x^n / n!
				i += 2;
				term *= x * x;
				term = BigFraction(term.GetNumerator(), i * (i - 1));

				isNegative = !isNegative;  // Alternate the sign for each term
			}
			break;
		}

		case DecimalPrecisionMode::Full:
		{
			BigFraction precision = GetFullPrecision();
			while (term.Abs() > precision)
			{
				if (isNegative)
				{
					result -= term;
				}
				else
				{
					result += term;
				}

				// Prepare for the next term: x^n / n!
				i += 2;
				term *= x * x;
				term = BigFraction(term.GetNumerator(), i * (i - 1));

				isNegative = !isNegative;  // Alternate the sign for each term
			}
			break;
		}

		default:
			throw std::invalid_argument("Unknown PrecisionMode");
		}

		result.PrecisionMode = this->PrecisionMode;
		result.FixedPrecisionCount = this->FixedPrecisionCount;

		return result;
	}

	BigFraction BigFraction::Cosine(const BigFraction& x) const
	{
		BigFraction result(ONE, ONE);
		BigFraction term(ONE, ONE);
		BigInteger	i = 2;	// Factorial index starts at 2

		bool isNegative = true;

		switch (this->PrecisionMode)
		{
		case DecimalPrecisionMode::Fixed:
		{
			for (uint64_t round = this->FixedPrecisionCount + 1; round > 0; --round)
			{
				term *= x * x;
				term = BigFraction(term.GetNumerator(), i * (i - 1));

				if (isNegative)
				{
					result -= term;
				}
				else
				{
					result += term;
				}
				isNegative = !isNegative;  // Alternate the sign for each term

				i += 2;
			}
			break;
		}

		case DecimalPrecisionMode::Full:
		{
			BigFraction precision = GetFullPrecision();
			while (term.Abs() > precision)
			{
				term *= x * x;
				term = BigFraction(term.GetNumerator(), i * (i - 1));

				if (isNegative)
				{
					result -= term;
				}
				else
				{
					result += term;
				}
				isNegative = !isNegative;  // Alternate the sign for each term

				i += 2;
			}
			break;
		}

		default:
			throw std::invalid_argument("Unknown PrecisionMode");
		}

		result.PrecisionMode = this->PrecisionMode;
		result.FixedPrecisionCount = this->FixedPrecisionCount;

		return result;
	}

	BigFraction BigFraction::Tangent(const BigFraction& x) const
	{
		BigFraction sinResult = Sine(x);
		BigFraction cosResult = Cosine(x);

		if (cosResult.IsZero())
		{
			throw std::overflow_error("Tangent undefined for this input (cos(x) = 0).");
		}

		auto result = sinResult / cosResult;
		result.PrecisionMode = this->PrecisionMode;
		result.FixedPrecisionCount = this->FixedPrecisionCount;

		return result;
	}

	BigFraction BigFraction::Arctangent(const BigFraction& x) const
	{
		BigFraction result = x;
		BigFraction term = x;
		BigInteger	i = 3;

		switch (this->PrecisionMode)
		{
		case DecimalPrecisionMode::Fixed:
		{
			for (uint64_t round = this->FixedPrecisionCount; round > 0; --round)
			{
				term *= x * x;
				result -= term / i;
				i += 2;
			}
			break;
		}

		case DecimalPrecisionMode::Full:
		{
			BigFraction precision = GetFullPrecision();
			while (term.Abs() > precision)
			{
				term *= x * x;
				result -= term / i;
				i += 2;
			}
			break;
		}

		default:
			throw std::invalid_argument("Unknown PrecisionMode");
		}

		result.PrecisionMode = this->PrecisionMode;
		result.FixedPrecisionCount = this->FixedPrecisionCount;

		return result;
	}

	BigFraction BigFraction::Arcsine(const BigFraction& x) const
	{
		if (x > BigFraction(ONE, ONE) || x < BigFraction(-1, ONE))
		{
			throw std::invalid_argument("asin(x) is undefined for |x| > 1");
		}

		BigFraction result = x;
		BigFraction term = x;
		BigInteger	i = 1;

		switch (this->PrecisionMode)
		{
		case DecimalPrecisionMode::Fixed:
		{
			for (uint64_t round = 1; round <= this->FixedPrecisionCount; ++round)
			{
				term *= x * x * BigFraction(i, i + 1);
				i += 2;
				term = BigFraction(term.GetNumerator(), i * (i - 1));
				result += term;
			}
			break;
		}

		case DecimalPrecisionMode::Full:
		{
			BigFraction precision = GetFullPrecision();
			while (term.Abs() > precision)
			{
				term *= x * x * BigFraction(i, i + 1);
				i += 2;
				term = BigFraction(term.GetNumerator(), i * (i - 1));
				result += term;
			}
			break;
		}

		default:
			throw std::invalid_argument("Unknown PrecisionMode");
		}

		result.PrecisionMode = this->PrecisionMode;
		result.FixedPrecisionCount = this->FixedPrecisionCount;

		return result;
	}

	BigFraction BigFraction::Arccosine(const BigFraction& x) const
	{
		auto result = (GenerateSrinivasaRamanujanPI() / BigFraction(TWO, ONE)) - Arcsine(x);

		result.PrecisionMode = this->PrecisionMode;
		result.FixedPrecisionCount = this->FixedPrecisionCount;

		return result;
	}

	BigFraction::BigInteger BigFraction::Floor() const
	{
		if (IsNaN() || IsZero())
		{
			return BigInteger(0);
		}
		else
		{
			BigInteger result = (numerator * sign) / denominator;
			if (sign == -1 && (numerator * sign) % denominator != 0)
			{
				result -= 1;
			}
			return result;
		}
	}

	BigFraction::BigInteger BigFraction::Ceil() const
	{
		if (IsNaN() || IsZero())
		{
			return BigInteger(0);
		}
		else
		{
			BigInteger result = (numerator * sign) / denominator;
			if (sign == 1 && (numerator * sign) % denominator != 0)
			{
				result += 1;
			}
			return result;
		}
	}

	BigFraction::BigInteger BigFraction::Round() const
	{
		if (IsNaN())
		{
			return BigInteger(0);
		}
		else if (IsZero())
		{
			return BigInteger(0);
		}
		else
		{
			BigInteger numeratorTwice = (numerator << 1);
			BigInteger denominatorTwice = (denominator << 1);
			BigInteger result = (numeratorTwice + denominator) / (denominatorTwice * sign);
			return result;
		}
	}

	BigFraction::operator BigInteger() const
	{
		if (IsNaN() || IsZero())
		{
			return 0;
		}

		std::optional<BigInteger> nullable_result = this->TryGetInteger();
		if (nullable_result.has_value())
			return nullable_result.value();
		else
			return BigInteger(0);
	}

	long double BigFraction::BigIntegerToLongDouble(const BigInteger& big_integer) const
	{
		long double result = 0.0;
		long double factor = 1.0;

		BigInteger temp = big_integer;
		while (!temp.IsZero())
		{
			// Extract the last digit
			BigInteger digit = temp % TEN;

			// Convert this digit to long double and add to the result
			result += static_cast<long double>(digit.ToUnsignedInt()) * factor;

			// Prepare to process the next digit
			temp /= TEN;
			factor *= 10.0;
		}

		return result;
	}

	BigFraction::operator long double() const
	{
		return sign * (BigIntegerToLongDouble(this->numerator) / BigIntegerToLongDouble(this->denominator));
	}

	BigFraction::operator double() const
	{
		return static_cast<double>(static_cast<long double>(*this));
	}

	BigFraction::operator float() const
	{
		return static_cast<float>(static_cast<long double>(*this));
	}

	std::istream& operator>>(std::istream& is, BigFraction& fraction)
	{
		std::string input;
		is >> input;
		fraction.ComputeAndFromDecimalString(input);
		return is;
	}

	std::ostream& operator<<(std::ostream& os, const BigFraction& fraction)
	{
		std::string output;
		output = fraction.ComputeAndToDecimalString();
		os << output;
		return os;
	}

	BigFraction operator+(const BigInteger& left, const BigFraction& right)
	{
		return right + left;
	}

	BigFraction operator-(const BigInteger& left, const BigFraction& right)
	{
		return right - left;
	}

	BigFraction operator*(const BigInteger& left, const BigFraction& right)
	{
		return right + left;
	}

	BigFraction operator/(const BigInteger& left, const BigFraction& right)
	{
		return right + left;
	}

	void BigFraction::ReduceSimplify()
	{
		// Handle case where numerator is zero
		if (this->numerator.IsZero())
		{
			this->sign = 1;  // Zero has no sign
			this->denominator = BigInteger(1);  // Denominator becomes 1 (0/1)
			return;
		}

		// Handle case where denominator is zero
		if (this->denominator.IsZero())
		{
			if (this->numerator == ONE)
			{
				//inline BigFraction BigFractionFullPrecision(1, 0);
				return;
			}
			throw std::invalid_argument("Denominator cannot be zero.");
		}

		// Calculate the greatest common divisor (GCD) to simplify the fraction
		BigInteger gcd = BigInteger::GCD(this->numerator, this->denominator);

		// Simplify the numerator and denominator using the GCD
		this->numerator /= gcd;
		this->denominator /= gcd;
	}

	/*
		Logarithm of a BigInteger using continued fractions
		The function uses the series expansion of the natural logarithm:
		\[
		\ln(1+x) = 2 \left( \frac{x}{1} - \frac{x^3}{3} + \frac{x^5}{5} - \cdots \right)
		\]
		The function uses \( x = \frac{value + 1}{1} \), ensuring \( |x| > 0 \).
	*/
	BigFraction BigFraction::LogarithmCF(const BigInteger& value) const
	{
		if (value <= 0)
		{
			throw std::invalid_argument("Logarithm is undefined for non-positive values.");
		}

		if (value == 1)
		{
			return BigFraction(0, 1); // log_e(1) = 0
		}

		// Step 1: Compute k = floor(log2(value)) using bit length
		size_t k = value.BitLength() - 1; // BitLength gives number of bits needed

		// Step 2: Compute m = value / 2^k
		BigInteger two_power_k = BigInteger::TwoPowerN(k); // 2^k as BigInteger
		BigFraction m = BigFraction(value, two_power_k); // value / 2^k

		// Step 3: Compute x = m - 1
		BigFraction x = m - BigFraction(1, 1);

		// Step 4: Sum Taylor series for ln(m)
		BigFraction taylor_sum(0, ONE);
		BigFraction term = x;
		BigInteger n = ONE;
		bool round_flag = true;

		switch (this->PrecisionMode)
		{
		case DecimalPrecisionMode::Fixed:
		{
			// Main loop to calculate
			for (uint64_t round = this->FixedPrecisionCount + 1; round > 0; round--)
			{
				if (round_flag)
				{
					taylor_sum += (term / n);
				}
				else
				{
					taylor_sum -= (term / n);
				}
				term *= x;
				n += 1;

				round_flag = !round_flag;  // Toggle round_flag for the next term
			}

			break;
		}

		case DecimalPrecisionMode::Full:
		{
			// Set precision for the calculation
			BigFraction precision = GetFullPrecision(); // 10^-n precision (1 / n)
			BigFraction different_value(0, ONE);
			BigFraction old_taylor_sum(0, ONE);
			while (true)
			{
				old_taylor_sum = taylor_sum;

				if (round_flag)
				{
					taylor_sum += (term / n);
				}
				else
				{
					taylor_sum -= (term / n);
				}
				term *= x;
				n += 1;

				different_value = (taylor_sum - old_taylor_sum).Abs();

				if (different_value < precision)
				{
					break;
				}

				round_flag = !round_flag;  // Toggle round_flag for the next term
			}

			break;
		}

		default:
			throw std::invalid_argument("Unknown PrecisionMode");
		}

		// Step 5: Compute ln(value) = ln(m) + k * ln(2)
		BigFraction result = taylor_sum + BigFraction(k, 1) * LOG_E2;

		result.PrecisionMode = this->PrecisionMode;
		result.FixedPrecisionCount = this->FixedPrecisionCount;

		return result;
	}

	BigFraction BigFraction::LogarithmHalley(const BigInteger& a) const
	{
		// 1. 校验
		if (a <= 0)
		{
			throw std::invalid_argument("Logarithm is undefined for non-positive values.");
		}
		if (a == 1)
		{
			// ln(1) = 0
			return BigFraction(0, 1);
		}

		// 2. 根据 a 的大小选一个初始猜测 y0
		//    如果 a > 1, 取正值；如果 a < 1, 取负值。
		BigFraction initial_guess(0, 1);

		// 2.1 把 a 转成 BigFraction
		BigFraction A(a, 1);

		// 2.2 如果 a > 1，可以先估计一下 log2(a) ，再乘以 ln(2)
		if (a > 1)
		{
			// 假设我们有 a.BitLength() -> roughly floor(log2(a)) + 1
			// 这里做简单处理： initialGuess = (bitLength - 1) * ln(2)
			size_t Log_2 = a.BitLength() - 1;
			// bitLen ~ floor(log2(a)) + 1 
			// 这里简单取 (bitLen - 1)
			BigFraction approxLog2(Log_2);
			// LN2 是一个常量 BigFraction
			initial_guess = approxLog2 * LOG_E2;
		}
		else
		{
			// 0 < a < 1
			// ln(a) 是负数
			// 可以随便猜个负值，比如 -1.0, 或者 -(bitLen - 1)* log_e(2)
			// 当 a < 1, bitLen=1 也有可能
			// 这里简单写 -1
			initial_guess = BigFraction(1, 1, -1);
		}

		// 3. 开始迭代：这里用 Halley 方法来替代原来的牛顿法
		//    Halley 更新公式: y_{n+1} = y_n - (2*(e^y - a))/(e^y + a)
		BigFraction y = initial_guess;

		switch (this->PrecisionMode)
		{
		case DecimalPrecisionMode::Fixed:
		{
			for (uint64_t i = 0; i < this->FixedPrecisionCount; i++)
			{
				// 计算 e^y
				BigFraction e_y = Exponential(y);
				// Halley 更新公式
				BigFraction new_y = y - (TWO * (e_y - A)) / (e_y + A);
				y = new_y;
			}
			break;
		}

		case DecimalPrecisionMode::Full:
		{
			// 设定一个阈值 precision
			BigFraction precision = this->GetFullPrecision(); // 10^-n
			BigFraction different_value(0, 1);

			while (true)
			{
				BigFraction e_y = Exponential(y);
				// Halley 更新公式
				BigFraction new_y = y - (TWO * (e_y - A)) / (e_y + A);
				different_value = (new_y - y).Abs();
				y = new_y;

				// 如果步长小于 precision，认为收敛
				if (different_value < precision)
				{
					break;
				}
			}
			break;
		}

		default:
			break;
		}

		// 4. 返回结果
		BigFraction result = y;
		result.PrecisionMode = this->PrecisionMode;
		result.FixedPrecisionCount = this->FixedPrecisionCount;
		return result;
	}

	/*
		@brief Generate a BigFraction representing the value of π (Pi) using the Srinivasa Ramanujan series.

		@details
		This function precomputes the value of π based on a high-precision calculation using the Ramanujan series.
		The series is implemented in Python code, which is used to generate the large numerator and denominator that represent π as a fraction.
		The numerator and denominator are then used to create a BigFraction object, which is simplified before returning.
		This approach ensures that the value of π is available as a precomputed fraction, avoiding the need for real-time calculation.

		Here's the Python code used for the precomputation:

		```python
		import decimal
		import math
		import sys

		# Increase the maximum allowed string length unlimited
		sys.set_int_max_str_digits(0)

		def ramanujan_pi(iterations):
			decimal.getcontext().prec = 10000  # Setting High Precision (10000) Floating Number
			total_sum = decimal.Decimal(0)
			factor = decimal.Decimal(2 * math.sqrt(2)) / decimal.Decimal(9801)

			for k in range(iterations):
				numerator = decimal.Decimal(math.factorial(4 * k)) * decimal.Decimal(1103 + 26390 * k)
				denominator = (decimal.Decimal(math.factorial(k)) ** 4) * (decimal.Decimal(396) ** (4 * k))
				total_sum += numerator / denominator

			pi_inv = factor * total_sum
			pi_value = 1 / pi_inv

			return pi_value

		# Calculate 2000 iterations
		iterations = 2000
		pi_value = ramanujan_pi(iterations)

		# Extract the numerator and denominator
		numerator = pi_value.as_integer_ratio()[0]
		denominator = pi_value.as_integer_ratio()[1]

		print(f"numerator: {numerator * 4}")
		print("\n")
		print(f"denominator: {denominator * 4}")
		```

		@returns A BigFraction object representing the value of π, which is precomputed and stored as a fraction.
	*/
	BigFraction BigFraction::GenerateSrinivasaRamanujanPI()
	{
		static BigInteger numerator
		(
			"3141592653589793023709380780717486763469833607826720486919923336894437464007835588165042081964422742587908889560773603151602852252160721362604174811891856615759117890464640476568650178481249677573589790684201235888650294353755998754685334341161547519996739479088998029573036973027413119828620943663789725484131700408126609909622220518805590414926449571875506022908156575184488006635859659116582117046254701384522374966358155301272693553353003579630093035050347617539808771920501672319758479656692221558575312251138967002902152245874255769149955239237448955176839985431847020706153743905502399179299646534937041554002789010027961962404319344317286479510693244584354856919020779537843922119464912373073596572509774070303324515084520691906992844853606319349101668803386721721598040581777774166381273204366786202324958675881342695628474223358811039066984925125526569697961907489718469177713381893701508628667491043927677900003085691238567118912952987422332684754462530254905466964591042619559310506524647225038356053503517038314302522459085771358839391487226506563236692702240829730941639779948228827744194136658917165343179231213257234946968543185983639441766802188606222112905767965979508122349492249684602497365713780782464471588731382170390365980830890278333528243982312919799161908263914936503227238359902976561935855017607416271780661568874032546521026334890218008723205438436573308335005064367492649130650170928018997041850225811532040195032354048598916679277743469374504223598001834255935428585386570575108999193655530015169673080359135096125370607287492684886298690718642253474552538575943448760746261986701522809808106907856472453745548018843666778246347149199421242796654197581930022582079252315784443840828099414976684367185149593612697279014481924167803593224961844806925090015708913389587171094241095715819246403640345543172057480914110903244374400952316134238229364711669612939589272446948764986560662622803554056559382613847375895090272960402640799417413219275841599247692537975220369891493369865122789481022660204430836546740679836647812978454578829074438622280447133004537289961496898199570487997874049473858235886677924248439420091039036310792704707026395624936939772365850056540274223425967005733999430968934506361300522095662329222033832903147074107889445193213728511664854793343852929172217730802019849568383847258473682687297207396191198944675921694663985208768130199129729807581992912097840078948767054754182676043961089110174429550908179188926388525337029878502685792221563622587586281868524789668842682653706593305182025066942224885298542175285628276455007702606472975814022406582691276168482734482757548369089586081975059391171129937574473723464153781854038582808728063370266549256305374990709200838108880168637423218889972603741587261798443770711093880615118922854878352301092878360016581833083063796618609368560241339159973874058629627138496986957631689871966254367254692956016379279448874683514281697004585555838564094418793338671368601173283704279073264965621690114064163235967729047883678416938917360002662535574528001196028215302453291901414717614600696089088354944244872431473782146646549712341516997796893078368238399904995381372061217567030618141243103498561744102841802985521647089277639437300673578556292373521599048508968947191382785903832432096668474344277696879602308885004950094917338132091884244421556370764488766399194839163626522234902751110737457211049911174568301928147415503014754416774043957433847893694785409916513148219571185372567798354645049837538654975228391463026784522026597955601234576727383064854311734139929145523402730741308615148210849533160273611408093565534511040013619706768849711043039694441521436006230947022332470959566068470691867582191855083701316378489719328591195689069354659130487014161868594172673350216663277301691150694975210755044585491762698066726264933918570727604759370840023937155558976535205544633307037314341960814595142969678651164854900062052682375651304373110563708342214734229470223681470230598001528372515949904254126483361524256786119046607150486946747513923300132335334290552640264108500388387291830751227506544509937301108765242136976866033825559241024945848607760003293610855149590207321802916476179936413209498751741099917117536481867385756081467849181086543602558278671172621773183128767338464839072635482329208341076533849065486005633578823644980895674874814663633094149528247410024877704871589581048881448260785927925357406609766919636607124333090807039441203490162917213030073195157309806722571721189320811111998133983521352185213707654009114090777260475015280805214010264455322619562970660791845656136278837466933803484193289144633586607951884942199975081830697347368353459261525046295069253375685203745184207201811183310386415905512533784895016226113091116920913979948260132412940549405854316594516311413935495255754539029650323689081007305484829618500825623681045381720113050775362565963415506847761984095288535565073224371145227836278093741190695756046686900149906825888402745968279246664474543404354218687538349444360405132953411773298517497228759665835101956249664015661048571240124316778599130443353380120629718508221873141765987615029543277136549168464463724544465494823904572005407004627473127584895621731056373583468352382157005014699571087501345848191379197114799652448184684818851888265068686223796834237587693896798209671550603077765102737669629723508752354696921126498329031840018428798972348445733274940484389487056230452993218717555619104357673937753014266824925302391909770093491762086901539892947985841047335743914076544526749317495459734627724103549936674936500250301134345241447198730534051586395737604085703543307638410357859477130448737926160116472027269473499498146921778284651273321201672858633014706488279535141505655970508841846973152726038158459259967424206162310284514104641115514199153920869006353513232855992404859245247266096594878918155566968997564271536244247139090518438561950433940704422950780668437889813864845754275242920220467683526692442641673503116888608705494551283975409530358884429640980840337716868871554816068171842163957370346976226738185347192616868853204846914310311728383177527746839500269324590464469117470578733605488924704091005178740426595860064130817310663233151471144416040310203241712574536090311125719468868993116026322949195731736125991046267291312078758615046876249250413541844800158460466692839048049420957692952630565359153216167897529094652111091676763973661333781792264792034682896638878219415167588018025409136728700983504076092070000404609139935368544507065552421876995983711294370049986596241378077194007304544643985475595992586076745819079292802472079967344678577954317571092089959694363032071190402983091985758714360755322553521501424563152644426182235933638137668836186451770778409801518371725847352000520701933611650918127675360216365415529123796498215225979259103442031400380021241821842689867797576033741744519322264493007474668562974586374537167728336487776105942433944733282156571732250243056394273921658652039731080722114524064625769557833608385182903514299666176186441179909557778923856483007322585868408528199630707008303498691339912527417301003810368242727936748025244401398499198688464120740561575064360814427028321428494242927759259907161081256461880488801124264519696751121929777337697296918083391990682514884222544659014979102139780103182018908087152666529633723673903790866485059052298410791861757073430812765471538670135716265932746400680574054350431845951309233881437138098678458085346842423063602078847880518973052534405747774280795479915223652589718020125038148391713446349520634295268714164606702848528953573912330766578943849648665400560242279744674704366642894349720908559036136888708887437569889425993586258982909028117530167893997692056999040629395135172375818515395445369828010046330460837239260622396808291177613087636541788098972112926287266524279547679518282670611894125989443203301329257898487627835942704025351734394945351999410131708603239940151333764248510744376662573647894624494306642363285829771726827126548344402442246949888899965353421769780552428881648079186894058715627846680578448610533223108675789156231386049596475498142971853371447399194258999715574357245637638791870276973059117170960132771522954878032027926681833333432294243463443913662141907600439484219516404241703851144323140221349842147253314280341684921778387050952885937821620599976779539665994690828662197591341314184570081952425501467330421649934310790261081756901449012936412161621770515170401057628778539013774220877552340877133062275434087953505487562564930296077907269657271039288482629112033961213176612237444785087523305340245808982039163674739258598449256669526977523373126926926923544823465953812988598399765159900240954587994332560312037636833856817035544310293622934924313089072467398449710106895830784551398430023100638738307564050995932795449059005652972237992774901139488974834159911922358906998870276984744952053574252905159601424255330351733799322600085194434602405461667911708944292600576587052775995273452240685728385266887193683280523752366308117373074694118919082891081889985180948069033785256139650394489967907496819460275020120328022994414608832820641501741473108139577644145941549625473709010873763851051698737916672922259933468572706809041971495043166195273836938132811168899921267300290801489951426267089033543305519511449106001268096318451795396654502450228578069587839886642271864371429315036494641853154565423407165389300056232375884216025534326981014491597593867590291649891133838080333553381278677737443083675185797906825663100782274080252595954156530207594319100315519346741046836656660980348364999038905553876569662126845926187795704615118730434819797628871327842386157908672190409767034891352072250610050519688360016428811002139103014995717798183643707474907109830500853426027283949736918796709850534911841150660022856254730773056579346191390587605162184243439582962748081157152566065449356279943670296526991087372955418776305676070036489238833526058783749616075783489231264761755624293075690040432851452",
			10
		);

		static BigInteger denominator
		(
			"1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
			10
		);

		//π
		auto pi = BigFraction(numerator, denominator);

		pi.ReduceSimplify();

		return pi;
	}

	BigFraction BigFraction::GenerateNilakanthaArrayPI(uint64_t iteration)
	{
		using __LAMINA::BIGINT::BigInteger;
		using __LAMINA::BIGFRAC::BigFraction;

		// Initial value π = 3
		BigFraction pi(3, 1);

		// Initial numerator = 4
		BigInteger numerator(4);

		// Initial denominator terms 2, 3, 4
		BigInteger denominator1(2);
		BigInteger denominator2(3);
		BigInteger denominator3(4);

		for (uint64_t i = 0; i < iteration; ++i)
		{
			// constructed fraction term：4 / (denominator1 * denominator2 * denominator3)
			BigFraction term(numerator, denominator1 * denominator2 * denominator3);

			// alternate addition and subtraction
			if (i % 2 == 0)
			{
				pi += term;
			}
			else
			{
				pi -= term;
			}

			// Updating denominator terms: (2n+2), (2n+3), (2n+4)
			denominator1 += 2;
			denominator2 += 2;
			denominator3 += 2;
		}

		// Set a very high precision denominator for the final value
		__LAMINA::BIGINT::BigInteger FullPrecision(
			"1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
			10
		);
		pi.SetFullPrecision(FullPrecision);

		// You can now output the result if needed (though you asked not to)
		//std::cout << "Pi approximated using " << iteration << " iterations: " << pi << std::endl;

		//std::cout << "Pi squared: " << pi.Power(2) << std::endl;
		//std::cout << "Square root of Pi: " << pi.Sqrt() << std::endl;
		//std::cout << "Cube root of Pi: " << pi.Cbrt() << std::endl;
		//std::cout << "Logarithm of Pi: " << pi.Log() << std::endl;
		//std::cout << "Log10 of Pi: " << pi.Log10() << std::endl;

		return pi;
	}

}  // namespace __LAMINA::BIGFRAC